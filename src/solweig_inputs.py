# -*- coding: utf-8 -*-
"""SOLWEIG-inputs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e3rEbd7r08mNYyWI1edqQfFoev3p_8Tw
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import xarray as xr

import geopandas as gpd
from city_metrix.layers import UrbanLandUse, TreeCanopyHeight, OvertureBuildings, AlosDSM, NasaDEM
from rasterio.enums import Resampling
from exactextract import exact_extract

import sys
sys.dont_write_bytecode=True

# %load_ext autoreload
# %autoreload

"""# Inputs"""

# Inputs
## Name of the area of interest
aoi_name='ba_roi'

## Data folder
def file_path_prefix(file_prefix):
    folder = f'./data/{file_prefix}'
    os.makedirs(folder, exist_ok=True)
    return f'{folder}/{file_prefix}'

## Path to polygon file the area you want data for
aoi_url = 'data/ba_roi.geojson'

"""# Get Polygon for AOI"""

# load boundary


# If you are using an SSO accout, you need to be authenticated first
# !aws sso login
aoi_gdf = gpd.read_file(aoi_url, driver='GeoJSON')

aoi_gdf = aoi_gdf.to_crs(epsg=4326)

## Write to file

file_path = f'{file_path_prefix(aoi_name)}-boundary.geojson'
aoi_gdf.to_file(file_path, driver='GeoJSON')
print(f'File saved to {file_path}')



## Get area in km2 of the city rounded to the nearest integer
aoi_gdf_area = aoi_gdf['geometry'].to_crs(epsg=3857).area/ 10**6 # in km2
aoi_gdf_area = round(aoi_gdf_area.values[0])
print(f'Area: {aoi_gdf_area} sqkm')

"""# LULC"""

# Commented out IPython magic to ensure Python compatibility.
# Load data
# %autoreload


# Load layer
aoi_UrbanLandUse = UrbanLandUse().get_data(aoi_gdf.total_bounds)

# Get resolution of the data
aoi_UrbanLandUse.rio.resolution()

# Convert values to integers
aoi_UrbanLandUse = aoi_UrbanLandUse.astype(int)

# Create a table of the land use types and their counts from aoi_UrbanLandUse DataArray
land_use_counts = aoi_UrbanLandUse.groupby(aoi_UrbanLandUse).count().to_dataframe()
land_use_counts

# Remove zeros
remove_value = 0

def count_occurrences(data, value):
    return data.where(data==value).count().item()

count = count_occurrences(aoi_UrbanLandUse, remove_value)

if count > 0:
    print(f'Found {count} occurrences of the value {remove_value}. Removing...')
    aoi_UrbanLandUse = aoi_UrbanLandUse.where(aoi_UrbanLandUse!=remove_value, drop=True)
    count = count_occurrences(aoi_UrbanLandUse, remove_value)
    print(f'There are {count} occurrences of the value {remove_value} after removing.')
else:
    print(f'There were no occurrences of the value {remove_value} found in data.')



def remap(raster, from_values, to_values):
    """
    Remap values in a raster dataset.

    Parameters:
    - raster: xarray.DataArray, the raster data to remap.
    - from_values: list of int, original values to be remapped.
    - to_values: list of int, new values after remapping.

    Returns:
    - remapped raster as xarray.DataArray
    """
    # Ensure input lists are of the same length
    if len(from_values) != len(to_values):
        raise ValueError("from_values and to_values must have the same length")

    # Copy the original raster to avoid modifying it directly
    remapped_raster = raster.copy()

    # Apply remapping
    for from_val, to_val in zip(from_values, to_values):
        remapped_raster = xr.where(remapped_raster == from_val, to_val, remapped_raster)

    return remapped_raster

# Assuming from_v2 and to_v2 are defined as in the excerpt
from_v2 =    [1, 2, 3, 10, 20, 30, 40, 41, 42, 43, 44, 50]
to_v2 =      [1, 2, 3,  4,  5,  6,  7,  7,  7,  7,  7,  8]
to_solweig = [5, 1, 6,  5,  7,  1,  2,  2,  2,  2,  2,  1]

# Apply the remap function
aoi_UrbanLandUse_to_solweig = remap(aoi_UrbanLandUse, from_v2, to_solweig)

aoi_UrbanLandUse_to_solweig.plot()

# Create a table of the land use types and their counts from aoi_UrbanLandUse DataArray
land_use_counts_to_v2 = aoi_UrbanLandUse_to_v2.groupby(aoi_UrbanLandUse_to_v2).count().to_dataframe()
land_use_counts_to_v2

# Create a table of the land use types and their counts from aoi_UrbanLandUse DataArray
land_use_counts_to_solweig = aoi_UrbanLandUse_test.groupby(aoi_UrbanLandUse_test).count().to_dataframe()
land_use_counts_test = land_use_counts_to_solweig

land_use_counts_test == land_use_counts_to_solweig

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-UrbanLandUseV2.tif'
aoi_UrbanLandUse_to_solweig.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')

"""# High Resolution 1m Global Canopy Height Maps

https://gee-community-catalog.org/projects/meta_trees/

"""


# Load layer
aoi_TreeCanopyHeight = TreeCanopyHeight().get_data(aoi_gdf.total_bounds)

aoi_TreeCanopyHeight.rio.resolution()

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-TreeCanopyHeight.tif'
aoi_TreeCanopyHeight.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')

"""# Building footprints"""



# Load layer
aoi_OvertureBuildings = OvertureBuildings().get_data(aoi_gdf.total_bounds)

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-OvertureBuildings.geojson'
aoi_OvertureBuildings.to_file(file_path, driver='GeoJSON')
print(f'File saved to {file_path}')

"""# DSM"""



aoi_AlosDSM = AlosDSM().get_data(aoi_gdf.total_bounds)

aoi_AlosDSM.rio.resolution()

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-aoi_AlosDSM.tif'
aoi_AlosDSM.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')



dsm_1m = aoi_AlosDSM.rio.reproject(
            dst_crs=aoi_AlosDSM.rio.crs,
            resolution=1,
            resampling=Resampling.bilinear
        )

dsm_1m.rio.resolution()

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-aoi_AlosDSM_1m.tif'
dsm_1m.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')

"""# DEM"""

# Commented out IPython magic to ensure Python compatibility.
# %autoreload


aoi_NasaDEM = NasaDEM().get_data(aoi_gdf.total_bounds)

aoi_NasaDEM.rio.resolution()

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-aoi_NasaDEM.tif'
aoi_NasaDEM.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')

dem_1m = aoi_NasaDEM.rio.reproject(
            dst_crs=aoi_NasaDEM.rio.crs,
            resolution=1,
            resampling=Resampling.bilinear
        )

# Save data to file
file_path = f'{file_path_prefix(aoi_name)}-aoi_NasaDEM_1m.tif'
dem_1m.rio.to_raster(raster_path=file_path, driver="COG")
print(f'File saved to {file_path}')

"""# Building height"""

aoi_height = aoi_AlosDSM - aoi_NasaDEM



aoi_OvertureBuildings = aoi_OvertureBuildings.to_crs(aoi_AlosDSM.rio.crs)

aoi_OvertureBuildings['AlosDSM_max'] = exact_extract(aoi_AlosDSM, aoi_OvertureBuildings, ["max"], output='pandas')['max']
aoi_OvertureBuildings['NasaDEM_max'] = exact_extract(aoi_NasaDEM, aoi_OvertureBuildings, ["max"], output='pandas')['max']
aoi_OvertureBuildings['height_max'] = exact_extract(aoi_height, aoi_OvertureBuildings, ["max"], output='pandas')['max']

aoi_OvertureBuildings

# Write to file
file_path = f'{file_path_prefix(aoi_name)}-BuildingHights.geojson'
aoi_OvertureBuildings.to_file(file_path, driver='GeoJSON')
print(f'File saved to {file_path}')

def rasterize_polygon(self, gdf, snap_to):
        if gdf.empty:
            raster = np.full(snap_to.shape, 0, dtype=np.int8)
            raster = xr.DataArray(raster, dims=snap_to.dims, coords=snap_to.coords)

            return raster.rio.write_crs(snap_to.rio.crs, inplace=True)

        raster = make_geocube(
            vector_data=gdf,
            measurements=["Value"],
            like=snap_to,
            fill=np.int8(0)
        ).Value

        return raster.rio.reproject_match(snap_to)

"""# ERA5"""

